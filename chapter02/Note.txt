객체지향 프로그래밍
이번장의 준비물 = 가벼운 마음가짐

1. 영화 예매 시스템
1) 요구사항 살펴보기

2. 객체지향 프로그래밍을 향해
1) 협력, 객체, 클래스
- Class부터 결정 X -> 객체에 초점을 맞춰야한다
- 어떤 객체들이 필요할까?
  객체는 기능을 구현하기 위해 협력하는 공동체의 일원
2) 도메인의 구조를 따르는 프로그램 구조
3) 클래스 구현하기
- 경계의 명확성이 객체의 자율성을 보장 + 프로그래머에게 구현의 자유 제공
- 객체의 자율?
    - 객체란 상태(state) + 행동(behavior)을 함께 가지는 복합적인 존재
    - 자율적인 존재 (의인화)
    - 캡슐화 : 데이터와 기능을 객체 내부로 묶는 것 -> "기존에는 데이터만 안으로 숨기는 것이라고 생각했는데 기능도 포함"
            자율성을 위해 외부의 간섭을 최소화 하는 것
    - 캡슐화와 접근 제어로 인해서 객체는 public interface와 implementation
- 프로그래머의 자유?
    - 클래스 작성자 : 새로운 데이터 타입을 프로그램에 추가
      클라이언트 프로그래머 : 필요한 클래스들을 엮어서 애플리케이션을 구축
      -> "마치 라이브러리를 사용하는 것과 비슷한 개념인 것 같음. 클래스를 구현하는 과정에서 이렇게 본인이 두가지의 역할을 하면서 구현하면 좋을듯?"
4) 협력하는 객체들의 공동체
- Money class를 만든 것은 명시적으로 개념을 표현 -> 설계의 명확성과 유연성을 높이는 길
5) 협력에 관한 짧은 이야기
- 함수 호출도 메시지 요청과 응답이라고 생각
- 메시지 수신 후 메시지를 처리하는 자신만의 방법을 method

3. 할인 요금 구하기
1) 할인 요금 계산을 위한 협력 시작하기
- movie class에는 할인 정책을 판단하는 코드가 없다. 단지 discountPolicy에게 메시지를 전송
- 상속? 다형성? 추상화?
2) 할인 정책과 할인 조건
- AmountDiscountPolicy와 PercentDiscountPolicy는 대부분의 코드 유사 -> 부모 클래스 DiscountPolicy를 추상클래스로 생성
  -> "c++에서는 pure virtual function이 하나 이상 포함 된 class"
- TEMPLATE METHOD 패턴 : 부모 클래스에서 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 패턴
3) 할인 정책 구성하기
- 생성자 파라미터를 이용해서 초기화에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진 객체의 생성을 보장

4. 상속과 다형성
1) 컴파일 시간 의존성과 실행 시간 의존성
- 코드의 의존성과 실행 시점의 의존성이 다를 수 있음 -> 클래스 사이의 의존성과 객체 사이의 의존성이 동일하지 않을 수 있음
  -> 의존성이 다를 수록 유연해지고 확장 가능 해짐 But 코드를 이해하기 어려워짐
2) 차이의 의한 프로그래밍
- 모두가 잘 알고 있을 듯
3) 상속과 인터페이스
- 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문.
  즉, 부모 클래스가 수신 할 수 있는 모든 인터페이스 수신 가능
- 업캐스팅(upcasting) : 자식 클래스가 부모 클래스를 대신 하는 것
4) 다형성
- 메세지와 메서드는 다르다!
- 동일한 메시지를 수신하는 객체의 클래스에 따라서 실행되는 메서드가 달라짐 -> 다형성
- 즉, 동일한 인터페이스를 가지고 있어야 하는데 이를 위해 사용한 구현 방법이 상속
- 다형성을 구현하는 방법은 다양하게 있지만, 모두 메시지에 응답해서 실행할 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있음
- 구현 상속과 인터페이스 상속이 있는데, 단순 코드 재사용을 위한 상속이 구현 상속. 구현 상속은 지양해야한다.
- "상속의 목적에 대해서 다시 한번 생각해 볼 수 있는 내용이었음"
5) 인터페이스와 다형성

5. 추상화와 유연성
1) 추상화의 힘
- 상위 정책을 기술 할 수 있다는 것은 기본적인 애플리케이션의 협력 흐름을 기술 할 수 있다는 것
2) 유연한 설계
- 할인 정책이 없는 경우를 예외 케이스로 취급하기 쉬운데 그러면 일관성이 무너짐
  -> NoneDiscountpolicy 생성. 클래스 생성으로 기능 확장이 되었음.
- Context independency
3) 추상 클래스와 인터페이스 트레이드오프
4) 코드 재사용
- 합성 VS 상속
5) 상속
- 상속을 한다는 것은 부모 클래스의 내부를 알아야 가능하기 때문에 캡슐화를 위반함
- 상속을 하게 되면 실행 시점에 객체의 종류를 변경하는 것이 불가능
6) 합성
- 인터페이스를 통해 약하게 결합함
- 코드 재사용을 위한 목적이라면 상속보다는 합성을 선호하는 것이 옳다
- 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 조합해서 사용할 수 밖에 없음

* 객체지향이란 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 절적한 객체에게 적절한 책임을 할당하는 것
  -> 다음장이 중요하다!