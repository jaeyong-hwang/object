서브클래싱과 서브타이핑

- 용도에 따른 상속 구분
    1) 타입 계층 구현을 위한 상속
        - 부모는 자식 클래스의 일반화, 자식은 부모 클래스의 특수화
    2) 코드 재사용을 위한 상속
        - 부모와 자식의 결합성 상승 -> 설계의 변경과 진화를 방해
    (빠른 결론) 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는
              객체의 행동을 기반으로 타입 계층을 구성해야 하고, 이를 타입 계층을 구성하기 용이하게 해주는 것이 상속

1. 타입이란?
    1) 개념적으론 우리가 인지하는 세상의 사물의 종류. 분류되는 대상은 인스턴스
        -> 심볼? 이름, 내연? 속성이나 행동, 외연? 객체들의 집합 (p.440)
    2) 프로그래밍적으로는 비트에 의미와 제약을 부여하기 위한 분류
        - 목적 1) 타입에 수행될 수 있는 유효한 오퍼레이션의 집합 정의
        - 목적 2) 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공
    3) 객체지향 프로그래밍에서 오퍼레이션 = 메시지, 즉, 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류
        -> 퍼블릭 인터페이스

2. 타입 계층
    포함하는 타입 : 일반적, 더 많은 인스턴스
    포함되는 타입 : 특수화
    슈퍼타입 : 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것.
    서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것.
    => 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.

3. 서브클래싱과 서브타이핑
    - 객체지향 프로그래밍에서 타입을 구현하는 일반적인 방법은 Class이고, 타입 계층을 구현하는 방법은 상속.
    1) 상속을 사용해야 할 때?
        - p.443 -> 하지만 is-a 보다 행동 호환성이 더 중요
        - 새와 팽귄의 이야기 -> 결국 클라이언트 입장에서의 행동 호환성이 더 중요
        - 인터페이스 분리 원칙 (ISP)
        - 자연어에 현혹되지 말고 클라이언트가 기대하는 행동에 집중하라
    2) 서브클래싱 : 재사용 목적의 상속
       서브타이핑 : 타입 계층을 위한 상속. 부모 클래스의 인스턷ㄴ스 대신 자식 클래스의 인스턴스를 사용할 목적으로 상속.
                -> 서브타입의 퍼블릭 인터페이스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와 동일하거나 많아야 함
                자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성을 포함힘
            
4. 리스코프 치환 원칙(LSP)
    - p.453
    - 정사각형과 직사각형
    - 정사각형이 직사각형을 대체할 수 없는 이유는 클라이언트의 관점에서 원하는 바가 다르기 때문

5. 계약에 의한 설계와 서브타이핑
    - 사전조건 : 서브타입에 더 강력한 사전조건을 정의할 수 없다. 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다
    - 사후조건 : 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다. 서브타입에 더 약한 사후조건을 정의할 수 없다